<?xml version="1.0" encoding="UTF-8"?>
<!--
To change this template, choose Tools | Templates
and open the template in the editor.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<ui:composition
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:ui="http://java.sun.com/jsf/facelets">
package org.conventionsframework.showcase.service.impl;

import org.conventionsframework.model.WrappedData;
import org.conventionsframework.qualifier.PersistentClass;
import org.conventionsframework.showcase.model.Person;
import org.conventionsframework.showcase.service.PersonService;
import java.util.Map;
import javax.ejb.SessionSynchronization;
import javax.ejb.Stateful;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.inject.Named;
import org.apache.commons.lang3.StringUtils;
import org.conventionsframework.exception.BusinessException;
import org.conventionsframework.service.impl.StatefulHibernateService;
import org.hibernate.criterion.DetachedCriteria;
import org.hibernate.criterion.MatchMode;
import org.hibernate.criterion.Restrictions;
import org.primefaces.model.SortOrder;

/**
 *
 * @author Rafael M. Pestano Mar 21, 2011 4:35:41 PM
 */
//Turning your service into an EJB will make your methods(the transactionAttribute ones)
// to run within an EJB transaction and auto flush of hibernate session. Note that Conventions will 
//flush hibernate session after Insert,remove or update so your service will still work if its not an EJB
//&lt;code&gt;@see org.conventionsframework.service.impl.BaseServiceImpl&lt;/code&gt; to see which methods are Transactional
@Stateful
@Named(value = "personService")
@PersistentClass(Person.class)
public class PersonServiceImpl extends StatefulHibernateService&lt;Person, Long&gt; implements PersonService {
    
    private boolean rollbackTest;
    
    //you can also change service entityManager but remember to set a valid
    //PersistenceContext, for example if your service extends StatelessHibernateService
    //only type= PersistenceContextType.TRANSACTION is allowed cause the service has
    //a Stateless EntityManagerProvider
    // just uncomment the block below
    /*
    @PersistenceContext(type= PersistenceContextType.TRANSACTION)
    private EntityManager entityManager;
    
    @PostConstruct
    public void initEntityManager(){
        getEntityManagerProvider().setEntityManager(entityManager);
    }
    */
    
    @Override
    @TransactionAttribute(TransactionAttributeType.NEVER)
    public WrappedData&lt;Person&gt; configFindPaginated(int first, int pageSize, String sortField, SortOrder sortOrder, Map filters, Map externalFilter) {

        DetachedCriteria dc = getDao().getDetachedCriteria();
        if (sortField == null || "".equals(sortField)) {
            sortField = "name";
        }
        if (externalFilter != null &amp;&amp; !externalFilter.isEmpty()) {
            String name = (String) externalFilter.get("name");
            if (name != null) {
                dc.add(Restrictions.ilike("name", name, MatchMode.ANYWHERE));
            }
            String lastname = (String) externalFilter.get("lastname");
            if (lastname != null) {
                dc.add(Restrictions.ilike("lastname", lastname, MatchMode.ANYWHERE));
            }
            String age = (String) externalFilter.get("age");
            if (age != null &amp;&amp; !StringUtils.isBlank(age)) {
                dc.add(Restrictions.eq("age", new Integer(age)));
            }
            Long ignoreId = (Long) externalFilter.get("ignoreId");
            if (ignoreId != null) {
                dc.add(Restrictions.ne("id", ignoreId));
            }
        }
        /*
         * config prime datatable filter columns
         */
        if (filters != null &amp;&amp; !filters.isEmpty()) {
            if (filters.get("name") != null) {
                dc.add(Restrictions.ilike("name", (String) filters.get("name"), MatchMode.ANYWHERE));
            }
            if (filters.get("lastname") != null) {
                dc.add(Restrictions.ilike("lastname", (String) filters.get("lastname"), MatchMode.ANYWHERE));
            }

            if (filters.get("age") != null) {
                dc.add(Restrictions.eq("age", new Integer((String) filters.get("age"))));
            }
        }
        return getDao().findPaginated(first, pageSize, sortField, sortOrder, dc);
    }

    @Override
    public boolean alowDeletePerson(Person entity) {
        if (entity.getAge() &gt; 60) {
            return false;
        }
        return true;
    }
    
     /**
      * IF your Service is an EJB the methods
      * after/before store/remove will run within an EJB transaction
      * so throwing an runtime exception will make the transaction 
      * to be rolled back. Also note that BusinessExcetions are 
      * ApplictionException so rollback will NOT be performed when they are thrown
      */
    
    @Override
    public void beforeStore(Person entity) {
        //override to perform logic before storing an entity
        super.beforeStore(entity);
    }
    
    
    @Override
    public void afterStore(Person entity) {
          //override to perform logic after storing an entity
          if(rollbackTest){
            // runtime will make the transaction rollback and user will be redirected to error page 
            throw new RuntimeException("Rolling back the transaction, all changes will be lost and your EJB instance will be lost.");
        }
       
    }
    
    @Override
    public void beforeRemove(Person entity) {
          //override to perform logic before removing an entity
        if (this.alowDeletePerson(entity)) {
             super.beforeRemove(entity);
        } else {
              //BusinessException is ApplicationException so no rollback will be performed
              //only FacesMessage error will be queued
            throw new BusinessException("Not allowed to remove person above 60 year old.");
        }
       
    }
    
    @Override
    public void afterRemove(Person entity) {
        //override to perform logic after removing an entity
        super.afterRemove(entity);
    }
    


    public void setRollbackTest(boolean rollbackTest) {
        this.rollbackTest = rollbackTest;
    }

}

    </ui:composition>